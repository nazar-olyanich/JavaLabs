Давайте розглянемо відповіді на ваші контрольні питання:
2)
1. **Ключові та зарезервовані слова**
   - Ключові слова є частиною синтаксису мови програмування, кожне з них має специфічне значення та використовується для виконання певної функції у мові програмування (наприклад, `if`, `else`, `class` у Java).
   - Зарезервовані слова це слова, які зарезервовані для майбутнього використання або слова, які використовуються в мета-програмуванні (наприклад, `goto` у Java).

2. **Примітивні типи даних**
   - `byte`: 8-бітний знаковий тип, ефективний для зберігання невеликих числових даних, наприклад, для обробки файлів або мережевих потоків.
   - `short`: 16-бітний знаковий тип, використовується для зберігання середніх цілих чисел (наприклад, звукові дані).
   - `int`: 32-бітний знаковий тип, загальне використання для числових операцій (наприклад, рахунок у футбольному матчі).
   - `long`: 64-бітний знаковий тип, для великих числових значень (наприклад, довжина файлу).
   - `float`: 32-бітний тип з плаваючою комою, для чисел з дробовою частиною, коли точність double не потрібна (наприклад, заробітна плата).
   - `double`: 64-бітний тип з плаваючою комою, для точних наукових та інженерних обчислень (наприклад, маса всесвіту).
   - `char`: 16-бітний тип, що представляє символ Unicode (наприклад, знаки тексту).
   - `boolean`: представляє значення істинності (true/false), використовується для логічних умов (наприклад, умовне виконання коду).

3. **Знакові та беззнакові типи**
   - Знакові типи можуть представляти як позитивні, так і негативні значення (наприклад, `byte`, `short`, `int`, `long` у Java).
   - Беззнакові типи представляють тільки позитивні значення або нуль. У Java відсутні вбудовані беззнакові типи, хоча є деякі способи обходу (наприклад, використання `char` як беззнакового 16-бітного типу).

4. **Максимальні числа для примітивних типів**
   - `short`: 32767 (2^15 - 1)
   - `char`: 65535 (2^16 - 1, оскільки `char` - беззнаковий)
   - `int`: 2,147,483,647 (2^31 - 1)
   - `long`: 9,223,372,036,854,775,807 (2^63 - 1)

5. **Діапазон значень byte**
   - `byte` має діапазон від -128 до 127, оскільки це 8-бітний знаковий тип, що може представляти 2^8 (256) різних значень. Від’ємні значення представляються від -128 до -1 (128 значень), а позитивні - від 0 до 127 (128 значень). Від’ємних значень не більше, ніж додатних, їх однакова кількість.

6. **Системи числення**
   - Система числення - це спосіб представлення чисел за допомогою символів. Щоб перевести значення з однієї системи числення в іншу, можна використовувати розкладання числа на степені основи системи числення та перерахунок.

7. **Доповняльний код**
   - Доповняльний код - це спосіб представлення від’ємних чисел у двійковій системі числення. Він отримується шляхом інвертування всіх бітів числа та додавання одиниці до результату.

8. **Результат роботи коду**
   - Цей код призведе до переповнення, оскільки сума `a + b` перевищує максимально можливе значення для `int`. Результат буде від'ємним числом через циклічне переповнення.

9. **Рі

зниця між float та double**
   - `float` - це 32-бітний тип з плаваючою комою, `double` - 64-бітний. `Double` забезпечує більшу точність та діапазон значень порівняно з `float`.

10. **Число з рухомою комою**
    - Число з рухомою комою - це спосіб представлення дійсних чисел, де мантиса визначає значущі цифри числа, а степінь (або порядок) визначає, на яку позицію зсувається десяткова кома.

11. **Double.NaN**
    - `Double.NaN` представляє "Не Число" - спеціальне значення відповідно до стандарту IEEE з плаваючою комою, що використовується для позначення результату невизначених або помилкових операцій.

12. **Результат роботи коду**
    - Виведе `false`, оскільки `Double.NaN` не дорівнює навіть самому собі.

13. **Преінкремент та постінкремент**
    - Преінкремент (`++i`) спочатку збільшує значення `i`, а потім повертає його. Постінкремент (`i++`) спочатку повертає поточне значення `i`, а потім збільшує його.

14. **Різниця між логічним та побітовим AND**
    - Побітовий AND (`&`) застосовується до кожного біту двох чисел. Логічний AND (`&&`) є логічною операцією, яка повертає `true`, якщо обидва операнди істинні. Короткозамкнута версія (`&&`) не оцінює другий операнд, якщо перший є `false`.

15. **Різниця між OR та XOR**
    - OR (`|`) повертає `true`, якщо хоча б один з операндів є `true`. XOR (`^`) повертає `true`, тільки якщо рівно один з операндів є `true`.

16. **Фрагмент програми**
    - Перший вивід буде `false`, оскільки оператор присвоєння `=` повертає значення, яке було присвоєно змінній `a`.
Другий вивід буде `true`, оскільки значення `true` присвоюється змінній `b`.


3)
1. **Структурне програмування**
   Структурне програмування - це парадигма програмування, яка підкреслює важливість використання чітко організованих блоків коду (цикли, умовні конструкції тощо), уникнення "спагеті-коду" та обмеження використання оператора GOTO.

2. **Основні конструкції структурного програмування**
   - Послідовний виконавчий потік.
   - Вибір (умовні конструкції `if` та `switch`).
   - Цикли (`for`, `while`, `do-while`).

3. **Основні принципи структурного програмування**
   - Послідовність: виконання програми крок за кроком.
   - Вибір: виконання різних частин коду в залежності від певних умов.
   - Ітерація: повторне виконання певних частин коду.

4. **Оператор GOTO**
   Використання GOTO вважається поганою практикою, оскільки воно може ускладнювати читання та розуміння коду, призводячи до "спагеті-коду". В Java GOTO відсутній, оскільки мова підтримує структурне програмування.

5. **Спагеті-код**
   Це неструктурований, заплутаний код, який важко читати та підтримувати, зазвичай через надмірне використання операторів GOTO або відсутність чіткої структури.

6. **Проектування зверху-вниз**
   Підхід до проектування програмного забезпечення, де розробка починається з визначення найбільш загальних функцій, а потім рухається до більш детальних аспектів. Переваги включають легкість розуміння та підтримки структури програми.

7. **Область видимості ідентифікатора**
   Область видимості ідентифікатора визначає контекст, у якому змінні або функції можуть бути доступні та використані у програмі.

8. **Блок та його вплив на область видимості**
   Блок - це область коду, обмежена фігурними дужками `{}`. Він визначає область видимості для змінних, оголошених всередині нього, обмежуючи доступ до цих змінних лише цим блоком.

9. **Використання конструкцій умовного виконання**
   - `if`: перевірка однієї умови.
   - `if-else`: вибір між двома шляхами виконання.
   - Ланцюги `if-else if`: вибір між декількома умовами.
   - `switch`: вибір між багатьма варіантами виконання, заснований на одній змінній.
   - Тернарний оператор `?:`: коротка форма для `if-else` для простих виборів.

10. **Використання циклічних конструкцій**
    - `while`: використовується, коли кількість ітерацій невідома заздалегідь.
    - `do-while`: схожий на `while`, але гарантує виконання тіла циклу хоча б один раз.
    - `for`: ефективний у випадках, коли кількість ітерацій відома заздалегідь.

11. **Різниця між break та continue**
    - `break` використовується для негайного виходу з циклу.
    - `continue` переходить до наступної ітерації циклу, пропускаючи залишок тіла циклу.

12. **Мітки у Java**
    Мітки використовуються для контролю потоку всередині циклів, особливо вкладених. Вони можуть використовуватися з `break` або `continue` для управління певними циклами.

13. **Аналіз фрагменту коду**
    - Виведе "b is true", оскільки у другому `if` присвоюється `true` змінній `b`.
    - "a is false" і "a = b" не будуть в

иведені, оскільки умови `if` не будуть виконані.

14. **Аналіз фрагменту коду**
    - Виведе "3" та "4", оскільки змінна `a` буде мати значення 3 після інкрементацій, а у `switch` немає операторів `break`, тому виконаються всі наступні `case` після третього.

15. **Аналіз фрагменту коду**
Цей код призведе до результату `false`. У циклі `for` виконується цілочисельне ділення, що призводить до того, що `sum` завжди дорівнюватиме 0. Цілочисельне ділення в Java повертає ціле число, відкидаючи дробову частину.

4)
1. **Змінна та Масив**
   Змінна - це іменоване місце у пам'яті для зберігання одного значення. Масив - це колекція однотипних елементів, розташованих у послідовному порядку в пам'яті.

2. **Стек та Купа**
   Стек - область пам'яті, де зберігаються локальні змінні та інформація про виклики функцій. Купа - область для динамічного розподілу пам'яті, де створюються об'єкти. Основна різниця полягає в управлінні пам'яттю: стек - автоматичне (LIFO), купа - динамічне.

3. **Розташування змінних та масивів**
   Змінні можуть бути розташовані у стеку (локальні змінні) або як частина об'єкту у купі. Безпосередньо у купі змінні не розташовуються. Масиви у Java завжди створюються у купі, але посилання на масив може знаходитися у стеку.

4. **Посилання на масив та масив**
   Посилання на масив - це змінна, що містить адресу масиву у пам'яті. Вона може бути розташована у стеку або як частина об'єкту у купі. Масив - це сама структура даних, яка зберігається у купі.

5. **Індекси у масиві**
   Для масиву з 10 комірками перша комірка має індекс 0, а остання - індекс 9.

6. **Доступ до неіснуючої комірки масиву**
   Це призведе до винятку `ArrayIndexOutOfBoundsException`.

7. **Ініціалізація нового масиву**
   При створенні нового масиву без явної ініціалізації всі його комірки будуть проініціалізовані спеціальними значеннями за замовчуванням (нулі для числових типів, `false` для `boolean`, `null` для об'єктних типів).

8. **Дізнатися індекси масиву**
   Перший індекс завжди 0, останній індекс можна дізнатися за допомогою `array.length - 1`.

9. **Зміна розміру масиву**
   У Java не можна змінити розмір існуючого масиву. Щоб це зробити, потрібно створити новий масив більшого розміру та скопіювати в нього елементи зі старого.

10. **Копіювання посилання на масив**
    Копіювання посилання на масив просто створює ще одне посилання на той самий масив у пам'яті. Зміни в масиві через одне посилання відображатимуться і через інше.

11. **Втрата посилання на масив**
    Якщо втратити всі посилання на масив, масив стане недоступним для програми і пізніше може бути зібраний сміттєзбиральником.

12. **«for» та «for-each»**
    - `for` дозволяє контролювати індекс ітерації, модифікувати елементи, а також зупиняти чи продовжувати цикл за умовою.
    - `for-each` спрощує перебір елементів колекції або масиву, але не дозволяє контролювати індекс чи змінювати елементи.

13. **Запис значень у масив**
    - У масив `double[]` можна записати значення `int` (автоматичне приведення типів).
    - У масив `int[]` не можна записати значення `double` без явного приведення типу.


    - Виведе "a is false", "b is true" і "a = b", оскільки в умові використовується оператор присвоєння `=`, який присвоює значення та повертає його.
    - При виконанні цього фрагменту коду виведеться "2", "3" і "4", оскільки `a` інкрементується двічі і має значення 3. У `switch`, відсутність `break` призводить до "провалювання" через всі випадки після збігу.
Результатом буде `false`, оскільки у циклі використовується цілочисельне ділення, і `sum` залишиться 0.

5)
1. **Порівняння методів сортування**
   - **Сортування бульбашкою (Bubble Sort)**
     Переваги: простий у реалізації; ефективний на невеликих наборах даних або коли дані вже майже відсортовані.
     Недоліки: низька ефективність на великих наборах даних; висока кількість обмінів елементів.
   - **Сортування вибором (Selection Sort)**
     Переваги: простий у реалізації; нечутливий до розподілу вхідних даних; мінімальна кількість обмінів елементів.
     Недоліки: завжди виконує O(n²) порівнянь; неефективний на великих наборах даних.
   - **Сортування вставкою (Insertion Sort)**
     Переваги: простий у реалізації; висока ефективність на невеликих наборах даних; стабільний; працює добре на частково відсортованих масивах.
     Недоліки: неефективний на великих наборах даних.

2. **Оцінка алгоритмів**
   - **Час роботи**
     Бульбашка, Вибір, Вставка: у середньому і найгіршому випадках O(n²), у найкращому випадку O(n) (якщо дані вже відсортовані).
   - **Потреба у додатковій пам'яті**
     Всі три алгоритми: O(1) - не потребують додаткової пам'яті, крім невеликого сталого обсягу для зберігання змінних.
   - **Стабільність**
     Бульбашка та Вставка: стабільні (не змінюють відносний порядок рівних елементів).
     Вибір: нестабільний.

   Інші критерії для порівняння: простота реалізації, чутливість до розподілу вхідних даних, можливість використання на зв'язних списках тощо.

3. **Оптимальні та найгірші випадки**
   Всі три алгоритми ефективні на невеликих або частково відсортованих масивах. Вони стають неефективними на великих або відсортованих у зворотному порядку масивах. Сортування вставкою часто виявляється найкращим вибором для частково відсортованих масивів.

4. **Позначення складності алгоритмів**
   - O(1): постійна складність - час виконання не залежить від розміру вхідних даних.
   - O(n): лінійна складність - час виконання пропорційний розміру вхідних даних.
O(n²): квадратична складність - час виконання пропорційний квадрату розміру вхідних даних.
6)1. **Immutable Об'єкт**
   Immutable об'єкт - це об'єкт, стан якого не можна змінити після його створення. В Java об'єкти класу `String` є immutable. Це означає, що раз створений рядок не може бути змінений. Це робить рядки безпечнішими для багатопотокового використання, дозволяє кешування хеш-кодів рядків (що є корисним для колекцій, наприклад, HashMap) і уникнути небажаних побічних ефектів. Клас `String` задекларований як `final`, щоб запобігти його розширенню (наслідуванню), що гарантує іммутабельність.

2. **Регулярні Вирази**
   Регулярні вирази - це могутній інструмент для здійснення пошуку, заміни та аналізу тексту за допомогою заданого шаблону. Приклади:
   - `"^a.*b$"`: знаходить рядки, що починаються на 'a' і закінчуються на 'b'.
   - `"[0-9]+"`: знаходить одне або більше числових символів.
   - `"\\s"`: знаходить всі пробільні символи.

3. **Оператор `==` та Метод `equals()`**
   Оператор `==` порівнює посилання на об'єкти, тобто чи вони вказують на одну і ту ж область у пам'яті. Метод `equals()`, у свою чергу, порівнює зміст об'єктів. В класі `Object` метод `equals()` визначений таким чином, що він функціонально еквівалентний `==`, але багато класів (наприклад, `String`) перевизначають `equals()`, щоб забезпечити логічне порівняння змісту.

4. **Класи StringBuilder та StringBuffer**
   `StringBuilder` та `StringBuffer` використовуються для створення змінних рядків. Вони дозволяють модифікувати рядки без створення нових рядкових об'єктів. Основна різниця між ними полягає в синхронізації: `StringBuffer` є синхронізованим і тому безпечним для використання в багатопотокових додатках, тоді як `StringBuilder` не є синхронізованим, але працює швидше і є більш ефективним у використанні пам'яті.

5. **Прибирання Пробілів у Рядках**
   Простий спосіб прибрати пробіли на початку та кінці рядка у Java - використовувати метод `trim()` класу `String`. Наприклад:
   ```
   String trimmedString = originalString.trim();
   ```
   Метод `trim()` видаляє всі початкові та кінцеві пробільні символи з рядка.
7)
1. **Collections Framework**
   Collections Framework у Java призначений для надання стандартних шаблонів для зберігання та обробки груп об'єктів. Він включає різноманітні інтерфейси, класи та алгоритми для роботи з колекціями, такими як списки, множини, карти тощо.

2. **Різниця між Масивами та Колекціями**
   - Масиви є фіксованого розміру та містять елементи одного типу.
   - Колекції є гнучкішими у термінах розміру та функціональності, вони можуть містити елементи різних типів (залежно від типізації) і підтримують різноманітні операції обробки даних.

3. **Особливості Списків**
   Списки у Java (наприклад, `ArrayList` та `LinkedList`) дозволяють зберігати впорядковані колекції елементів, забезпечують доступ до елементів за індексом, дозволяють дублікати елементів, а також підтримують вставку та видалення елементів.

4. **Різниця між Списками та Масивами**
   - Списки є частиною Collections Framework та надають більше функціональності, такої як вставка, видалення елементів і розширення при необхідності.
   - Масиви мають фіксований розмір та не підтримують таку гнучкість.

5. **ArrayList vs LinkedList**
   - `ArrayList` заснований на динамічному масиві, забезпечує швидкий доступ до елементів за індексом.
   - `LinkedList` заснований на двонаправленому списку, забезпечує швидку вставку та видалення елементів.
   Використовуйте `ArrayList` для частих операцій доступу до елементів, а `LinkedList` - для частих вставок та видалень.

6. **Iterator**
   Iterator використовується для ітерування елементів колекції. Переваги ітератора включають можливість видалення елементів під час ітерації та універсальність для будь-якого типу колекції, на відміну від класичного циклу `for`.

7. **Типізовані та Нетипізовані Колекції**
   - Типізовані колекції використовують Generics для вказівки конкретного типу елементів, які можуть бути збережені у колекції.
   - Нетипізовані колекції не використовують Generics і можуть містити об'єкти будь-якого типу.

8. **Інтерфейс RandomAccess**
   Інтерфейс `RandomAccess` в Java використовується як маркер для позначення, що колекція підтримує швидкий доступ до своїх елементів за індексом, наприклад, у `ArrayList`.

9. **Collection vs Collections**
   - `Collection` є основним інтерфейсом у Collections Framework, з якого виходять інші колекційні інтерфейси, такі як `List`, `Set`, тощо.
`Collections` є утилітним класом в Java, що містить статичні методи для роботи з колекціями, такі як сортування, пошук тощо.
8)
1. **Інтерфейси Set, Collection, та List**
   - `Collection` є основним інтерфейсом, з якого виходять інші колекційні інтерфейси, включаючи `Set` та `List`.
   - `List` зберігає елементи в порядку вставки та дозволяє дублікати.
   - `Set` не дозволяє дублікатів та не гарантує порядок зберігання елементів.

2. **HashSet vs TreeSet**
   - `HashSet` використовує хеш-таблицю, не гарантує порядку елементів і пропонує кращу продуктивність для операцій додавання, видалення та пошуку.
   - `TreeSet` заснований на червоно-чорному дереві, зберігає елементи в сортованому порядку та має більш високу вартість операцій порівняно з `HashSet`.

3. **Хешування, Хеш, Хеш-код, Хеш-функція**
   - Хешування - це процес перетворення вхідних даних будь-якої довжини в рядок фіксованої довжини.
   - Хеш - результат хеш-функції.
   - Хеш-код - це цілочисельне значення, отримане за допомогою хеш-функції.
   - Хеш-функція - це функція, яка перетворює великий обсяг даних у невелике цілочисельне значення.

4. **Вимоги до Коректної Хеш-Функції**
   - Рівномірний розподіл: хеш-функція повинна рівномірно розподіляти дані по всьому діапазону хеш-кодів.
   - Ефективність: хеш-функція повинна бути швидкою для обчислення.
   - Детермінованість: одні й ті ж вхідні дані завжди повинні давати один і той же хеш-код.

5. **Властивості Хорошої Хеш-Функції**
   - Рівномірний розподіл хеш-кодів.
   - Мінімізація колізій (різні вхідні дані, які дають однаковий хеш-код).
   - Швидке обчислення.

6. **Умови для Об'єктів в HashSet**
   Об'єкти, що зберігаються в `HashSet`, повинні коректно реалізувати методи `equals()` та `hashCode()`. Це забезпечує правильне порівняння об'єктів та розподіл у хеш-таблиці.

7. **Переваги/Недоліки HashSet та TreeSet**
   - `HashSet` є швидшим для операцій додавання, видалення та пошуку, але не гарантує порядку елементів.
   - `TreeSet` забезпечує впорядкованість елементів, але має вищі витрати на операції через підтримку сортованост

і.

8. **Size та Capacity**
   - `size` відноситься до кількості елементів у колекції.
   - `capacity` відноситься до розміру внутрішнього масиву, який зберігає елементи.
   `size` може бути меншим або рівним `capacity`, але не більшим. `capacity` може бути більшим за `size`, що дозволяє колекції рости без перевиділення пам'яті.

9. **Load Factor**
   Load factor - це показник, що визначає, коли потрібно збільшити ємність хеш-таблиці (`HashSet`, `HashMap`). Він впливає на баланс між часом доступу та пам'яттю.

10. **Асоціативний Масив**
    Асоціативний масив - це структура даних, що зберігає пари ключ-значення. Ключ відрізняється від значення тим, що він унікальний та використовується для ідентифікації запису.

11. **Ключі та Значення в Асоціативному Масиві**
    У асоціативному масиві не може бути кілька однакових ключів, але можуть бути однакові значення.

12. **Неімутабельні Об'єкти у HashSet/HashMap**
    Зберігання неімутабельних об'єктів у `HashSet` або як ключів у `HashMap` забезпечує стабільність хеш-кодів та правильність роботи колекції. Якщо об'єкти мутабельні, їх зміна після вставки може призвести до некоректної поведінки колекції.

13. **Comparable у TreeMap**
    Так, об'єкти, які не реалізують `Comparable`, можуть зберігатися в `TreeMap`, але потрібно надати зовнішній компаратор (реалізація `Comparator`).

14. **Comparable у HashMap**
    Наявність інтерфейсу `Comparable` у об'єктів не впливає на їх зберігання в `HashMap`, оскільки `HashMap` не залежить від порядку або можливості порівняння елементів.
